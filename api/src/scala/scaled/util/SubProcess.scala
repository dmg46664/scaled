//
// Scaled - a scalable editor extensible via JVM languages
// http://github.com/scaled/scaled/blob/master/LICENSE

package scaled.util

import java.io.{BufferedReader, Reader, PrintWriter}
import java.io.{InputStream, InputStreamReader, OutputStreamWriter}
import java.nio.file.{Path, Paths}
import java.util.concurrent.{Executor => JExecutor}
import java.util.function.Consumer
import scaled._

/** Factory methods &c for [[SubProcess]. */
object SubProcess {

  /** Configures a to-be-created subprocess. */
  case class Config (
    /** The command and arguments to be executed. */
    cmd :Array[String],
    /** The environment in which to invoke the command. Defaults to empty. */
    env :Map[String,String] = Map(),
    /** The current working directory for the process. Defaults to Scaled's cwd. */
    cwd :Path = Paths.get(System.getProperty("user.dir"))
  )

  /** An event generated by a sub-process. */
  sealed trait Event
  /** An event generated when a line of output is received from the sub-process.
    * @param isErr true if the output came from stderr, false if it came from stdout. */
  case class Output (text :String, isErr :Boolean) extends Event
  /** An event generated if the sub-process fails to start, or if an error occurrs reading from
    * stdout or stderr. */
  case class Failure (cause :Throwable, isErr :Boolean) extends Event
  /** An event generated when EOF is reached on a sub-process input stream.
    * @param isErr whether EOF came on stderr (true) or stdout (false). */
  case class Complete (isErr :Boolean) extends Event

  /** Starts a subprocess with the specified configuration. Output will be directed to `buffer`. If
    * the subprocess fails to start, the starting exception will be captured, recorded to `buffer`
    * and then rethrown.
    * @param onExit a function that will be called with `false` if stdout is closed due to
    * failure, `true` if it's closed normally. */
  def apply (config :Config, exec :Executor, buffer :Buffer,
             onExit :Consumer[Boolean] = noopOnExit) :SubProcess = {
    val events = Signal[Event](exec.ui)
    events.onValue { _ match {
      case Output(text, _) => buffer.append(Line.fromTextNL(text))
      case Complete(isErr) => if (!isErr) onExit.accept(true)
      case Failure(cause, isErr) =>
        buffer.append(Line.fromTextNL(Errors.stackTraceToString(cause)))
        if (!isErr) onExit.accept(false)
    }}
    new SubProcess(config, events)
  }

  private def noopOnExit (success :Boolean) {}
}

/** Encapsulates a sub-process.
  * @param config the launch configuration for the sub-process.
  * @param events a signal to which events from this sub-process will be emitted. Note that events
  * are emitted from background worker threads, so this signal should generally be created with the
  * UI executor. Note also that events may be emitted *during* the construction of this SubProcess,
  * so any listeners should already be in place before the signal is passed into this constructor.
  */
class SubProcess (config :SubProcess.Config, events :Signal[SubProcess.Event]) extends Closeable {
  import SubProcess._

  /** Sends `line` to the subprocess's stdin. A newline is automatically appended. */
  def send (line :String) {
    out.println(line)
    out.flush()
  }

  /** Sends `lines` to the subprocess's stdin. Newlines are automatically appended. */
  def send (lines :Seq[String]) {
    lines foreach out.println
    out.flush()
  }

  /** Returns true if this subprocess is still alive. */
  def isAlive :Boolean = process.isAlive

  /** Closes this subprocess's output stream. This may trigger termination if it expects that sort
    * of thing. This must only be called after [[start]]. */
  override def close () {
    process.getOutputStream.close()
  }

  /** Returns the PID of this subprocess, if we can get it. This is only available on Unix
    * platforms. */
  def pid :Option[Int] = process.getClass.getName match {
    case "java.lang.UNIXProcess" =>
      val cl = process.getClass
      val field = cl.getDeclaredField("pid")
      field.setAccessible(true)
      Some(field.get(process).asInstanceOf[Integer])
    case _ => None
  }

  /** Terminates the subprocess, less than forcibly. */
  def terminate () {
    process.destroy()
  }

  /** Terminates the subprocess forcibly. */
  def kill () {
    process.destroyForcibly()
  }

  /** Waits for the process to complete and returns its exit code. */
  def waitFor () :Int = {
    process.waitFor()
  }

  override def toString = s"SubProcess(${config.cmd.mkString(" ")})"

  private def read (reader :BufferedReader, isErr :Boolean) :Unit = try {
    while (true) {
      val line = reader.readLine
      if (line == null) {
        events.emit(Complete(isErr))
        return
      }
      events.emit(Output(line, isErr))
    }
  } catch {
    case e :Exception => events.emit(Failure(e, isErr))
  }

  private lazy val process = {
    val pb = new ProcessBuilder(config.cmd :_*)
    pb.directory(config.cwd.toFile)
    config.env foreach { (k, v) => pb.environment.put(k, v) }
    pb.start
  }

  protected lazy val out =
    new PrintWriter(new OutputStreamWriter(process.getOutputStream, "UTF-8"))

  // filter out CR to avoid wonkiness on Windows: TODO: make this optional?
  private class FilterCRReader(source :Reader) extends Reader {
    override def read :Int = {
      val c = source.read()
      if (c == '\r') this.read
      else c
    }

    override def read (cbuf :Array[Char], offset :Int, length :Int) = {
      var read = source.read(cbuf, offset, length)
      var filtered = 0
      var ii = 0; while (ii < read) {
        val pos = offset+ii
        if (cbuf(pos) == '\r') {
          System.arraycopy(cbuf, pos+1, cbuf, pos, read-ii-1)
          ii -= 1
          read -= 1
          filtered += 1
        }
        ii += 1
      }
      read
    }

    override def close () = source.close()
  }

  private def lineReader (is :InputStream) =
    new BufferedReader(new FilterCRReader(new InputStreamReader(is, "UTF-8")))

  // kick things off immediately; if the process fails to start, an exception will be thrown before
  // these threads are started; otherwise they'll run until the process's streams are closed
  try {
    val in  = lineReader(process.getInputStream)
    val err = lineReader(process.getErrorStream)
    new Thread("Subproc: stdin") {
      setDaemon(true)
      override def run () = read(in, false)
    }.start()
    new Thread("Subproc: stderr") {
      setDaemon(true)
      override def run () = read(err, true)
    }.start()
  } catch {
    case err :Throwable => events.emit(Failure(err, true))
  }
}
